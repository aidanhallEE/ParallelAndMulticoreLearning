#include <iostream> //output
#include <fstream> // write to file
#include <chrono> //time
#include <atomic> //threads
#include <thread> //Need this for threads i think?
#include <math.h> // Sqrt
#include <tuple> // For multi output
#include <iomanip>
#include <vector> // i dont even know anymore
using namespace std;
std::vector<std::thread> threads;

// Declare Variables
int rangeInput;
int threadInput;

atomic<int> finalTotal = 0;
atomic<int> finalSum = 0;
float finalTime;

int lala[4]; // Placeholder for array
ofstream File("Output.txt");

// Declare Functions

void ResultsToFile(float time, int total, int sum, int array[]);
void ThreadSorter(int n, int threadNum);
void PrimeFinder(int Start, int End) {
	int sen = 0;
	int threadSum = 0;
	int threadTotal = 0;

	for (int i = Start; i < End + 1; i++) {
		for (int j = 2; j < sqrt(i); j++) { //Sqrt of i reduces time
			if (i % j == 0) {
				sen = 1;
				break;
			}
		}
		if (sen == 0) {
			threadTotal++;
			threadSum = threadSum + i;
			//cout << i << ", ";
		}
		else {
			sen = 0;
		}
	}
	// Output
	finalTotal.fetch_add(threadTotal);
	finalSum.fetch_add(threadSum);
}

int main() {
	// Input
	cout << "Enter Range: ";
	cin >> rangeInput;

	cout << "Enter # of Threads: ";
	cin >> threadInput;

	// DO IT
	// Start Clock
	std::chrono::steady_clock::time_point begin = std::chrono::steady_clock::now();

	// Do function
	ThreadSorter(rangeInput, threadInput);

	// End clock
	std::chrono::steady_clock::time_point end = std::chrono::steady_clock::now();

	//Finalize Data
	finalTime = (std::chrono::duration_cast<std::chrono::milliseconds>(end - begin).count()/(float)1000);

	// Print results
	ResultsToFile(finalTime, finalTotal, finalSum, lala);

	// Makes VS happy
	return 1;
}

void ResultsToFile(float time, int total, int sum, int array[]) {
	//<execution time> <total number of primes found> <sum of all primes found> <top ten maximum primes, listed in order from lowest to highest>
	File << fixed << setprecision(4) << time << "s | Total #: " << total << " | Sum: " << sum << " | " << array;
	File.close();
}


void ThreadSorter(int n, int threadNum) {
	//Define vars
	int firstValue = 2;
	int secondValue = n / 2;

	//Clear it out
	threads.clear();

	for (int t = 0; t < threadNum; t++) {
		if (t + 1 == threadNum) {
			// Can be used to define last thread to find biggest 10 values	
			//thread th{ PrimeFinder(firstValue, n)};
			threads.emplace_back(std::thread(PrimeFinder, firstValue, n));
		}
		else {
			//thread th{ PrimeFinder(firstValue, secondValue) };
			threads.emplace_back(std::thread(PrimeFinder, firstValue, secondValue-1));
			firstValue = secondValue;	
			secondValue = (secondValue / 2) + firstValue;
		}
	}

	// Join the threads
	for (int i = 0; i < threadNum; i++)
	{
		threads[i].join();
	}
}